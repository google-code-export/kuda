/*
 * Port of O3D's gpu-enabled particle system to Three.js with minor modifications.
 * @author Erik Kitson
 */

/*
 * Copyright 2009, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var hemi=hemi||{};(function(){function f(a){var b=new Uint8Array(a.length),c;for(var d=0;d<a.length;++d)c=a[d]*256,b[d]=c>255?255:c<0?0:c;return b}function e(b){this.validateParameters(b);var c=a[b.billboard?"particle2d":"particle3d"];this.material.attributes=THREE.UniformsUtils.clone(c.attributes),this.material.uniforms=THREE.UniformsUtils.clone(c.uniforms),this.material.vertexShader=c.vertexShader,this.material.fragmentShader=c.fragmentShader,this._timeParam=this.material.uniforms.time}function d(a,c,d,e){var f=this.material.attributes,g=this.material.uniforms,h=f.uvLifeTimeFrameStart,i=f.positionStartTime,j=f.velocityStartSize,k=f.accelerationEndSize,l=f.spinStartSpinSpeed,m=f.orientation,n=f.colorMult,o=d.worldVelocity,p=d.worldAcceleration,q=this._particleSystem._randomFunction,r=function(a){return(q()-.5)*a*2},s=function(a,b){var c=[];for(var d=0,e=a.length;d<e;++d)c[d]=a[d]+r(b[d]);return c};g.colorSampler.texture=this._colorTexture,g.rampSampler.texture=this._rampTexture,g.timeRange.value=d.timeRange,g.numFrames.value=d.numFrames,g.frameDuration.value=d.frameDuration,g.worldVelocity.value.set(o[0],o[1],o[2]),g.worldAcceleration.value.set(p[0],p[1],p[2]),d.billboard&&(g.viewInverse.value=this._camera.matrixWorld);for(var t=0;t<c;++t){e&&e(t,d);var u=d.lifeTime,v=d.startTime===null?t*u/c:d.startTime,w=d.frameStart+r(d.frameStartRange),x=s(d.position,d.positionRange),y=s(d.velocity,d.velocityRange),z=s(d.acceleration,d.accelerationRange),A=s(d.colorMult,d.colorMultRange),B=d.spinStart+r(d.spinStartRange),C=d.spinSpeed+r(d.spinSpeedRange),D=d.startSize+r(d.startSizeRange),E=d.endSize+r(d.endSizeRange),F=d.orientation;for(var G=0;G<4;++G){var H=t*4+G+a;h.value[H]=new THREE.Vector4(b[G][0],b[G][1],u,w),i.value[H]=new THREE.Vector4(x[0],x[1],x[2],v),j.value[H]=new THREE.Vector4(y[0],y[1],y[2],D),k.value[H]=new THREE.Vector4(z[0],z[1],z[2],E),l.value[H]=new THREE.Vector4(B,C,0,0),n.value[H]=new THREE.Vector4(A[0],A[1],A[2],A[3]),m&&(m.value[H]=new THREE.Vector4(F[0],F[1],F[2],F[3]))}}h.needsUpdate=!0,i.needsUpdate=!0,j.needsUpdate=!0,k.needsUpdate=!0,l.needsUpdate=!0,n.needsUpdate=!0,m&&(m.needsUpdate=!0)}function c(a){for(var b=0;b<a;++b){for(var c=0;c<4;++c)this.shape.vertices.push(new THREE.Vertex);var d=b*4;this.shape.faces.push(new THREE.Face3(d,d+1,d+2)),this.shape.faces.push(new THREE.Face3(d,d+2,d+3))}}hemi.particles=hemi.particles||{};var a={particle3d:{attributes:{uvLifeTimeFrameStart:{type:"v4",value:[]},positionStartTime:{type:"v4",value:[]},velocityStartSize:{type:"v4",value:[]},accelerationEndSize:{type:"v4",value:[]},spinStartSpinSpeed:{type:"v4",value:[]},orientation:{type:"v4",value:[]},colorMult:{type:"v4",value:[]}},uniforms:{worldVelocity:{type:"v3",value:new THREE.Vector3},worldAcceleration:{type:"v3",value:new THREE.Vector3},timeRange:{type:"f",value:0},time:{type:"f",value:0},timeOffset:{type:"f",value:0},frameDuration:{type:"f",value:0},numFrames:{type:"f",value:0},rampSampler:{type:"t",value:0,texture:null},colorSampler:{type:"t",value:1,texture:null}},vertexShader:"uniform vec3 worldVelocity;\nuniform vec3 worldAcceleration;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart; \nattribute vec4 positionStartTime; \nattribute vec4 velocityStartSize; \nattribute vec4 accelerationEndSize; \nattribute vec4 spinStartSpinSpeed; \nattribute vec4 orientation; \nattribute vec4 colorMult; \n\nvarying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\nvoid main() {\n  vec2 uv = uvLifeTimeFrameStart.xy;\n  float lifeTime = uvLifeTimeFrameStart.z;\n  float frameStart = uvLifeTimeFrameStart.w;\n  vec3 position = positionStartTime.xyz;\n  float startTime = positionStartTime.w;\n  vec3 velocity = (objectMatrix * vec4(velocityStartSize.xyz, 0)).xyz\n      + worldVelocity;\n  float startSize = velocityStartSize.w;\n  vec3 acceleration = (objectMatrix *\n      vec4(accelerationEndSize.xyz, 0)).xyz + worldAcceleration;\n  float endSize = accelerationEndSize.w;\n  float spinStart = spinStartSpinSpeed.x;\n  float spinSpeed = spinStartSpinSpeed.y;\n\n  float localTime = mod((time - timeOffset - startTime),\n      timeRange);\n  float percentLife = localTime / lifeTime;\n\n  float frame = mod(floor(localTime / frameDuration + frameStart),\n                     numFrames);\n  float uOffset = frame / numFrames;\n  float u = uOffset + (uv.x + 0.5) * (1.0 / numFrames);\n\n  v_texcoord = vec2(u, uv.y + 0.5);\n  v_colorMult = colorMult;\n\n  float size = mix(startSize, endSize, percentLife);\n  size = (percentLife < 0.0 || percentLife > 1.0) ? 0.0 : size;\n  float s = sin(spinStart + spinSpeed * localTime);\n  float c = cos(spinStart + spinSpeed * localTime);\n\n  vec4 rotatedPoint = vec4((uv.x * c + uv.y * s) * size, 0.0,\n                               (uv.x * s - uv.y * c) * size, 1.0);\n  vec3 center = velocity * localTime +\n                  acceleration * localTime * localTime + \n                  position;\n  \n      vec4 q2 = orientation + orientation;\n      vec4 qx = orientation.xxxw * q2.xyzx;\n      vec4 qy = orientation.xyyw * q2.xyzy;\n      vec4 qz = orientation.xxzw * q2.xxzz;\n  \n      mat4 localMatrix = mat4(\n        (1.0 - qy.y) - qz.z, \n        qx.y + qz.w, \n        qx.z - qy.w,\n        0,\n  \n        qx.y - qz.w, \n        (1.0 - qx.x) - qz.z, \n        qy.z + qx.w,\n        0,\n  \n        qx.z + qy.w, \n        qy.z - qx.w, \n        (1.0 - qx.x) - qy.y,\n        0,\n  \n        center.x, center.y, center.z, 1.0);\n  rotatedPoint = localMatrix * rotatedPoint;\n  gl_Position = projectionMatrix * modelViewMatrix * rotatedPoint;\n  v_percentLife = percentLife;\n}\n",fragmentShader:"varying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\n// We need to implement 1D!\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\n\nvoid main() {\n  vec4 colorMult = texture2D(rampSampler, \n      vec2(v_percentLife, 0.5)) * v_colorMult;\n  vec4 color = texture2D(colorSampler, v_texcoord) * colorMult;\n  gl_FragColor = color;\n}\n"},particle2d:{attributes:{uvLifeTimeFrameStart:{type:"v4",value:[]},positionStartTime:{type:"v4",value:[]},velocityStartSize:{type:"v4",value:[]},accelerationEndSize:{type:"v4",value:[]},spinStartSpinSpeed:{type:"v4",value:[]},colorMult:{type:"v4",value:[]}},uniforms:{viewInverse:{type:"m4",value:null},worldVelocity:{type:"v3",value:new THREE.Vector3},worldAcceleration:{type:"v3",value:new THREE.Vector3},timeRange:{type:"f",value:0},time:{type:"f",value:0},timeOffset:{type:"f",value:0},frameDuration:{type:"f",value:0},numFrames:{type:"f",value:0},rampSampler:{type:"t",value:0,texture:null},colorSampler:{type:"t",value:1,texture:null}},vertexShader:"uniform mat4 viewInverse;\nuniform vec3 worldVelocity;\nuniform vec3 worldAcceleration;\nuniform float timeRange;\nuniform float time;\nuniform float timeOffset;\nuniform float frameDuration;\nuniform float numFrames;\n\nattribute vec4 uvLifeTimeFrameStart; \nattribute vec4 positionStartTime; \nattribute vec4 velocityStartSize; \nattribute vec4 accelerationEndSize; \nattribute vec4 spinStartSpinSpeed; \nattribute vec4 colorMult; \n\nvarying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\nvoid main() {\n  vec2 uv = uvLifeTimeFrameStart.xy;\n  float lifeTime = uvLifeTimeFrameStart.z;\n  float frameStart = uvLifeTimeFrameStart.w;\n  vec3 position = (objectMatrix * vec4(positionStartTime.xyz, 1.0)).xyz;\n  float startTime = positionStartTime.w;\n  vec3 velocity = (objectMatrix * vec4(velocityStartSize.xyz, 0)).xyz \n      + worldVelocity;\n  float startSize = velocityStartSize.w;\n  vec3 acceleration = (objectMatrix *\n      vec4(accelerationEndSize.xyz, 0)).xyz + worldAcceleration;\n  float endSize = accelerationEndSize.w;\n  float spinStart = spinStartSpinSpeed.x;\n  float spinSpeed = spinStartSpinSpeed.y;\n\n  float localTime = mod((time - timeOffset - startTime),\n      timeRange);\n  float percentLife = localTime / lifeTime;\n\n  float frame = mod(floor(localTime / frameDuration + frameStart),\n                     numFrames);\n  float uOffset = frame / numFrames;\n  float u = uOffset + (uv.x + 0.5) * (1.0 / numFrames);\n\n  v_texcoord = vec2(u, uv.y + 0.5);\n  v_colorMult = colorMult;\n\n  vec3 basisX = viewInverse[0].xyz;\n  vec3 basisZ = viewInverse[1].xyz;\n\n  float size = mix(startSize, endSize, percentLife);\n  size = (percentLife < 0.0 || percentLife > 1.0) ? 0.0 : size;\n  float s = sin(spinStart + spinSpeed * localTime);\n  float c = cos(spinStart + spinSpeed * localTime);\n\n  vec2 rotatedPoint = vec2(uv.x * c + uv.y * s, \n                               -uv.x * s + uv.y * c);\n  vec3 localPosition = vec3(basisX * rotatedPoint.x +\n                                basisZ * rotatedPoint.y) * size +\n                         velocity * localTime +\n                         acceleration * localTime * localTime + \n                         position;\n\n  gl_Position = (projectionMatrix * viewMatrix * vec4(localPosition, 1.0));\n  v_percentLife = percentLife;\n}\n",fragmentShader:"varying vec4 v_position;\nvarying vec2 v_texcoord;\nvarying float v_percentLife;\nvarying vec4 v_colorMult;\n\n// We need to implement 1D!\nuniform sampler2D rampSampler;\nuniform sampler2D colorSampler;\n\nvoid main() {\n  vec4 colorMult = texture2D(rampSampler, \n      vec2(v_percentLife, 0.5)) * v_colorMult;\n  vec4 color = texture2D(colorSampler, v_texcoord) * colorMult;\n  gl_FragColor = color;\n}\n"}},b=[[-0.5,-0.5],[.5,-0.5],[.5,.5],[-0.5,.5]];hemi.particles.System=function(a){var b=[0,.2,.7,1,.7,.2,0,0],c=[];for(var d=0;d<8;++d)for(var e=0;e<8;++e){var g=b[e]*b[d];c.push(g,g,g,g)}var h=f(c),i=new THREE.DataTexture(h,8,8,THREE.RGBAFormat),j=f([1,1,1,1,1,1,1,.5,1,1,1,0]),k=new THREE.DataTexture(j,3,1,THREE.RGBAFormat);i.needsUpdate=k.needsUpdate=!0,this._randomFunction=a||function(){return Math.random()},this.defaultColorTexture=i,this.defaultRampTexture=k,this.emitters=[]},hemi.particles.System.prototype.createEmitter=function(a,b){return new hemi.particles.Emitter(this,a,b)},hemi.particles.System.prototype.createTrail=function(a,b,c,d,e){return new hemi.particles.Trail(this,a,b,c,d,e)},hemi.particles.System.prototype.update=function(a){for(var b=0,c=this.emitters.length;b<c;++b)this.emitters[b]._timeParam.value+=a},hemi.particles.Spec=function(){this.numParticles=1,this.numFrames=1,this.frameDuration=1,this.frameStart=0,this.frameStartRange=0,this.timeRange=99999999,this.startTime=null,this.lifeTime=1,this.lifeTimeRange=0,this.startSize=1,this.startSizeRange=0,this.endSize=1,this.endSizeRange=0,this.position=[0,0,0],this.positionRange=[0,0,0],this.velocity=[0,0,0],this.velocityRange=[0,0,0],this.acceleration=[0,0,0],this.accelerationRange=[0,0,0],this.spinStart=0,this.spinStartRange=0,this.spinSpeed=0,this.spinSpeedRange=0,this.colorMult=[1,1,1,1],this.colorMultRange=[0,0,0,0],this.worldVelocity=[0,0,0],this.worldAcceleration=[0,0,0],this.billboard=!0,this.orientation=[0,0,0,1]},hemi.particles.Emitter=function(a,b,c){this._camera=b,this._colorTexture=c||null,this._particleSystem=null,this._rampTexture=null,this._timeParam=null,this.material=new THREE.ShaderMaterial({blending:THREE.AdditiveBlending,depthWrite:!1,transparent:!0}),this.material.name="particles",this.shape=new THREE.Geometry,a&&(this._colorTexture=c||a.defaultColorTexture,this._rampTexture=a.defaultRampTexture,this._particleSystem=a,a.emitters.push(this))},hemi.particles.Emitter.prototype.setBlending=function(a){this.material.blending=a},hemi.particles.Emitter.prototype.setColorRamp=function(a){var b=a.length/4;b%1!==0&&hemi.error("colorRamp must have multiple of 4 entries");var c=f(a);this._rampTexture===this._particleSystem.defaultRampTexture||this._rampTexture.image.width!==b?(this._rampTexture=new THREE.DataTexture(c,b,1,THREE.RGBAFormat),this._rampTexture.needsUpdate=!0,this.uniforms&&(this.uniforms.rampSampler.texture=this._rampTexture)):this._rampTexture.image.data=c},hemi.particles.Emitter.prototype.validateParameters=function(a){var b=new hemi.particles.Spec;for(var c in a)typeof b[c]=="undefined"&&hemi.error('unknown particle parameter "'+c+'"');for(c in b)typeof a[c]=="undefined"&&(a[c]=b[c])},hemi.particles.Emitter.prototype.setParameters=function(a,b){e.call(this,a);var f=a.numParticles;c.call(this,f),d.call(this,0,f,a,b)},hemi.particles.Emitter.prototype.createOneShot=function(a){return new hemi.particles.OneShot(this,a)},hemi.particles.OneShot=function(a,b){this._emitter=a,this._timeOffsetParam=a.material.uniforms.timeOffset,this.transform=new THREE.Mesh(a.shape,a.material),this.transform.doubleSided=!0,this.transform.visible=!1,b&&b.add(this.transform)},hemi.particles.OneShot.prototype.trigger=function(a,b){b&&b.add(this._transform),a&&this._transform.position.copy(a),this._transform.visible=!0,this._timeOffsetParam.value=this._emitter._timeParam.value},hemi.particles.Trail=function(a,b,d,f,g,h){hemi.particles.Emitter.call(this,a,b,g),this._birthIndex=0,this._maxParticles=d,this._parameters=f,this._paramSetter=h,c.call(this,d),e.call(this,f)},hemi.particles.Trail.prototype=new hemi.particles.Emitter,hemi.particles.Trail.constructor=hemi.particles.Trail,hemi.particles.Trail.prototype.birthParticles=function(a){var b=this._parameters.numParticles;this._parameters.startTime=this._timeParam.value,this._parameters.position=a;while(this._birthIndex+b>=this._maxParticles){var c=this._maxParticles-this._birthIndex;d.call(this,this._birthIndex,c,this._parameters,this._paramSetter),b-=c,this._birthIndex=0}d.call(this,this._birthIndex,b,this._parameters,this._paramSetter),this._birthIndex+=b}})()